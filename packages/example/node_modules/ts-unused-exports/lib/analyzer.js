"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var util_1 = require("./parser/util");
var isExportArray = function (e) {
    return e.startsWith('[') && e.endsWith(']');
};
var parseExportArray = function (e) {
    return e
        .replace('[', '')
        .replace(']', '')
        .split(',')
        .map(function (e) { return e.trim(); });
};
var getFileExports = function (file) {
    var exports = {};
    file.exports.forEach(function (e, index) {
        var addExport = function (exportName) {
            exports[exportName] = {
                usageCount: 0,
                location: file.exportLocations[index],
            };
        };
        if (isExportArray(e)) {
            var exportArray = parseExportArray(e);
            exportArray.forEach(addExport);
        }
        else {
            addExport(e);
        }
    });
    return { exports: exports, path: file.fullPath };
};
var getExportMap = function (files) {
    var map = {};
    files.forEach(function (file) {
        map[file.path] = getFileExports(file);
    });
    return map;
};
var processImports = function (file, exportMap) {
    Object.keys(file.imports).forEach(function (key) {
        var _a, _b;
        var ex = (_a = exportMap[key]) === null || _a === void 0 ? void 0 : _a.exports;
        // Handle imports from an index file
        if (!ex && key === '.') {
            var indexCandidates = ['index', 'index.ts', 'index.tsx'];
            for (var c = 0; c < indexCandidates.length; c++) {
                var indexKey = indexCandidates[c];
                ex = ((_b = exportMap[indexKey]) === null || _b === void 0 ? void 0 : _b.exports) || undefined;
                if (ex)
                    break;
            }
        }
        if (!ex)
            return;
        var addUsage = function (imp) {
            if (!ex[imp]) {
                // The imported symbol we are checking was not found in the imported
                // file. For example:
                // `a.ts` import { b } from './b';
                // `b.ts` does not export a `b` symbol
                // In here `imp` is `b`, `imports` represents `a.ts` and `ex.exports`
                // are the symbols exported by `b.ts`
                ex[imp] = {
                    usageCount: 0,
                    location: {
                        line: 1,
                        character: 1,
                    },
                };
            }
            ex[imp].usageCount++;
        };
        file.imports[key].forEach(function (imp) {
            return imp === '*'
                ? Object.keys(ex)
                    .filter(function (e) { return e != 'default'; })
                    .forEach(addUsage)
                : addUsage(imp);
        });
    });
};
var expandExportFromStarOrStarAsForFile = function (file, exportMap, prefix, isWithAlias) {
    var fileExports = exportMap[file.path];
    file.exports
        .filter(function (ex) { return ex.startsWith(prefix); })
        .forEach(function (ex) {
        var _a;
        delete fileExports.exports[ex];
        var exports = (_a = exportMap[util_1.removeExportStarPrefix(ex)]) === null || _a === void 0 ? void 0 : _a.exports;
        if (exports) {
            Object.keys(exports)
                .filter(function (e) { return e != 'default'; })
                .forEach(function (key) {
                if (!isWithAlias) {
                    // Copy the exports from the imported file:
                    if (!fileExports.exports[key]) {
                        var export1 = exports[key];
                        fileExports.exports[key] = {
                            usageCount: 0,
                            location: export1.location,
                        };
                    }
                    fileExports.exports[key].usageCount = 0;
                }
                // else is export-as: so this file exports a new namespace.
                // Mark the items as imported, for the imported file:
                var importedFileExports = exportMap[util_1.removeExportStarPrefix(ex)];
                if (importedFileExports) {
                    importedFileExports.exports[key].usageCount++;
                }
            });
        }
    });
};
// export * from 'a' (no 'alias')
var expandExportFromStarForFile = function (file, exportMap) {
    expandExportFromStarOrStarAsForFile(file, exportMap, '*:', false);
};
// export * as X from 'a' (has 'alias')
var expandExportFromStarAsForFile = function (file, exportMap) {
    expandExportFromStarOrStarAsForFile(file, exportMap, '*as:', true);
};
var expandExportFromStar = function (files, exportMap) {
    files.forEach(function (file) {
        expandExportFromStarForFile(file, exportMap);
        expandExportFromStarAsForFile(file, exportMap);
    });
};
// Allow disabling of *results*, by path from command line (useful for large projects)
var shouldPathBeExcludedFromResults = function (path, extraOptions) {
    if (!extraOptions || !extraOptions.pathsToExcludeFromReport) {
        return false;
    }
    return extraOptions.pathsToExcludeFromReport.some(function (ignore) {
        return path.includes(ignore);
    });
};
var filterFiles = function (files, extraOptions) {
    var _a;
    if (!(extraOptions === null || extraOptions === void 0 ? void 0 : extraOptions.ignoreFilesRegex)) {
        return files;
    }
    var regexes = (_a = extraOptions.ignoreFilesRegex) === null || _a === void 0 ? void 0 : _a.map(function (rex) { return new RegExp(rex); });
    var shouldIgnoreFile = function (fileName) {
        return regexes.some(function (reg) {
            return reg.test(fileName);
        });
    };
    return files.filter(function (f) { return !shouldIgnoreFile(f.path); });
};
exports.default = (function (files, extraOptions) {
    var filteredFiles = filterFiles(files, extraOptions);
    var exportMap = getExportMap(filteredFiles);
    expandExportFromStar(filteredFiles, exportMap);
    filteredFiles.forEach(function (file) { return processImports(file, exportMap); });
    var analysis = {};
    Object.keys(exportMap).forEach(function (file) {
        var expItem = exportMap[file];
        var exports = expItem.exports, path = expItem.path;
        if (shouldPathBeExcludedFromResults(path, extraOptions))
            return;
        var unusedExports = Object.keys(exports).filter(function (k) { return exports[k].usageCount === 0; });
        if (unusedExports.length === 0) {
            return;
        }
        analysis[path] = [];
        unusedExports.forEach(function (e) {
            analysis[path].push({
                exportName: e,
                location: exports[e].location,
            });
        });
    });
    return analysis;
});
//# sourceMappingURL=analyzer.js.map