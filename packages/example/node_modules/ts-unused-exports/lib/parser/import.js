"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.addImportCore = exports.extractImport = void 0;
var common_1 = require("./common");
var path_1 = require("path");
var fs_1 = require("fs");
var util_1 = require("./util");
// Parse Imports
var EXTENSIONS = ['.d.ts', '.ts', '.tsx', '.js', '.jsx'];
var relativeTo = function (rootDir, file, path) {
    return path_1.relative(rootDir, path_1.resolve(path_1.dirname(file), path));
};
var isRelativeToBaseDir = function (baseDir, from) {
    return fs_1.existsSync(path_1.resolve(baseDir, from + ".js")) ||
        fs_1.existsSync(path_1.resolve(baseDir, from + ".ts")) ||
        fs_1.existsSync(path_1.resolve(baseDir, from + ".d.ts")) ||
        fs_1.existsSync(path_1.resolve(baseDir, from + ".tsx")) ||
        fs_1.existsSync(path_1.resolve(baseDir, from, 'index.js')) ||
        fs_1.existsSync(path_1.resolve(baseDir, from, 'index.ts')) ||
        fs_1.existsSync(path_1.resolve(baseDir, from, 'index.tsx'));
};
var extractImport = function (decl) {
    var from = common_1.getFrom(decl.moduleSpecifier);
    var importClause = decl.importClause;
    if (!importClause)
        return {
            from: from,
            what: common_1.STAR,
        };
    var namedBindings = importClause.namedBindings;
    var importDefault = !!importClause.name ? ['default'] : [];
    if (!namedBindings) {
        return {
            from: from,
            what: importDefault,
        };
    }
    var isStar = !!namedBindings.name;
    var importNames = isStar
        ? common_1.STAR
        : namedBindings.elements.map(function (e) { return (e.propertyName || e.name).text; });
    // note on namespaces: when importing a namespace, we cannot differentiate that from another element.
    // (we differentiate on *export*)
    return {
        from: from,
        what: importDefault.concat(importNames),
    };
};
exports.extractImport = extractImport;
var declarationFilePatch = function (matchedPath) {
    return matchedPath.endsWith('.d') && fs_1.existsSync(matchedPath + ".ts")
        ? matchedPath.slice(0, -2)
        : matchedPath;
};
var addImportCore = function (fw, rootDir, path, imports, baseDir, baseUrl, tsconfigPathsMatcher) {
    var from = fw.from, what = fw.what;
    var getKey = function (from) {
        if (from[0] == '.') {
            // An undefined return indicates the import is from 'index.ts' or similar == '.'
            return relativeTo(rootDir, path, from) || '.';
        }
        else {
            var matchedPath = void 0;
            if (isRelativeToBaseDir(baseDir, from)) {
                return path_1.join(baseUrl, from);
            }
            if (tsconfigPathsMatcher &&
                (matchedPath = tsconfigPathsMatcher(from, undefined, undefined, EXTENSIONS))) {
                var absoluteRootDir = path_1.resolve(rootDir);
                // Use join to normalize path separators, since tsconfig-path can return mixed path separators
                return path_1.join(declarationFilePatch(matchedPath)
                    .replace("" + absoluteRootDir + path_1.sep, '')
                    .replace("" + baseDir + path_1.sep, ''));
            }
            return from;
        }
    };
    var key = getKey(from);
    var items = imports[key] || [];
    imports[key] = items.concat(what).filter(util_1.isUnique);
    return key;
};
exports.addImportCore = addImportCore;
//# sourceMappingURL=import.js.map